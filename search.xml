<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot常用注解</title>
      <link href="/2023/01/01/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2023/01/01/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="SoringBoot常用注解"><a href="#SoringBoot常用注解" class="headerlink" title="SoringBoot常用注解"></a>SoringBoot常用注解</h1><p><strong>@RequestMapping</strong></p><p>@RequestMapping注解的主要用途是将Web请求与请求处理类中的方法进行映射。Spring MVC和Spring WebFlux都通过<code>RquestMappingHandlerMapping</code>和<code>RequestMappingHndlerAdapter</code>两个类来提供对@RequestMapping注解的支持。</p><p><code>@RequestMapping</code>注解对请求处理类中的请求处理方法进行标注；<code>@RequestMapping</code>注解拥有以下的六个配置属性：</p><ul><li><code>value</code>:映射的请求URL或者其别名</li><li><code>method</code>:兼容HTTP的方法名</li><li><code>params</code>:根据HTTP参数的存在、缺省或值对请求进行过滤</li><li><code>header</code>:根据HTTP Header的存在、缺省或值对请求进行过滤</li><li><code>consume</code>:设定在HTTP请求正文中允许使用的媒体类型</li><li><code>product</code>:在HTTP响应体中允许使用的媒体类型</li></ul><p>提示：在使用@RequestMapping之前，请求处理类还需要使用@Controller或@RestController进行标记</p><p>下面是使用@RequestMapping的两个示例：</p><p><img src="/../images/image-20230101183243145.png" alt="image-20230101183243145"></p><p>@RequestMapping还可以对类进行标记，这样类中的处理方法在映射请求路径时，会自动将类上@RequestMapping设置的value拼接到方法中映射路径之前，如下：</p><p><img src="/../images/image-20230101183257786.png" alt="image-20230101183257786"></p><hr><p><strong>@RequestBody</strong></p><p>@RequestBody在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过<code>HttpMessageConverter</code>传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值。此外，还可以通过@Valid注解对请求主体中的参数进行校验。</p><p>下面是一个使用<code>@RequestBody</code>的示例：</p><p><img src="/../images/image-20230101183316017.png" alt="image-20230101183316017"></p><hr><p><strong>@GetMapping</strong></p><p><code>@GetMapping</code>注解用于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是<code>@RequestMapping(method=RequestMethod.GET)</code>的快捷方式。</p><p>下面是<code>@GetMapping</code>的一个使用示例：</p><p><img src="/../images/image-20230101183332725.png" alt="image-20230101183332725"></p><hr><p><strong>@PostMapping</strong></p><p><code>@PostMapping</code>注解用于处理HTTP POST请求，并将请求映射到具体的处理方法中。@PostMapping与@GetMapping一样，也是一个组合注解，它相当于是<code>@RequestMapping(method=HttpMethod.POST)</code>的快捷方式。</p><p>下面是使用<code>@PostMapping</code>的一个示例：</p><p><img src="/../images/image-20230101183350327.png" alt="image-20230101183350327"></p><hr><p><strong>@PutMapping</strong></p><p><code>@PutMapping</code>注解用于处理HTTP PUT请求，并将请求映射到具体的处理方法中，@PutMapping是一个组合注解，相当于是<code>@RequestMapping(method=HttpMethod.PUT)</code>的快捷方式。</p><p>下面是使用<code>@PutMapping</code>的一个示例：</p><p><img src="/../images/image-20230101183420380.png" alt="image-20230101183420380"></p><hr><p><strong>@DeleteMapping</strong></p><p><code>@DeleteMapping</code>注解用于处理HTTP DELETE请求，并将请求映射到删除方法中。@DeleteMapping是一个组合注解，它相当于是<code>@RequestMapping(method=HttpMethod.DELETE)</code>的快捷方式。</p><p>下面是使用<code>@DeleteMapping</code>的一个示例：</p><p><img src="/../images/image-20230101183435129.png" alt="image-20230101183435129"></p><hr><p><strong>@PatchMapping</strong></p><p><code>@PatchMapping</code>注解用于处理HTTP PATCH请求，并将请求映射到对应的处理方法中。@PatchMapping相当于是<code>@RequestMapping(method=HttpMethod.PATCH)</code>的快捷方式。</p><p>下面是一个简单的示例：</p><p><img src="/../images/image-20230101183454534.png" alt="image-20230101183454534"></p><hr><p><strong>@ControllerAdvice</strong></p><p><code>@ControllerAdvice</code>是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。<code>@ControllerAdvice</code>需要和<code>@ExceptionHandler</code>、<code>@InitBinder</code>以及<code>@ModelAttribute</code>注解搭配使用，主要是用来处理控制器所抛出的异常信息。</p><p>首先，我们需要定义一个被<code>@ControllerAdvice</code>所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。</p><p>此外，在有必要的时候，可以使用<code>@InitBinder</code>在类中进行全局的配置，还可以使用@ModelAttribute配置与视图相关的参数。使用<code>@ControllerAdvice</code>注解，就可以快速的创建统一的，自定义的异常处理类。</p><p>下面是一个使用<code>@ControllerAdvice</code>的示例代码：</p><p><img src="/../images/image-20230101183518239.png" alt="image-20230101183518239"></p><hr><p><strong>@ResponseBody</strong></p><p><code>@ResponseBody</code>会自动将控制器中方法的返回值写入到HTTP响应中。特别的，<code>@ResponseBody</code>注解只能用在被<code>@Controller</code>注解标记的类中。如果在被<code>@RestController</code>标记的类中，则方法不需要使用<code>@ResponseBody</code>注解进行标注。<code>@RestController</code>相当于是<code>@Controller</code>和<code>@ResponseBody</code>的组合注解。</p><p>下面是使用该注解的一个示例</p><p><img src="/../images/image-20230101183534413.png" alt="image-20230101183534413"></p><hr><p><strong>@ExceptionHandler</strong></p><p><code>@ExceptionHander</code>注解用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被<code>@ExceptionHandler</code>标注的方法。</p><p>下面是使用该注解的一个示例：</p><p><img src="/../images/image-20230101183551017.png" alt="image-20230101183551017"></p><hr><p><strong>@ResponseStatus</strong></p><p><code>@ResponseStatus</code>注解可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值。</p><p>下面是使用<code>@ResponseStatus</code>注解的一个示例：</p><p><img src="/../images/image-20230101183617313.png" alt="image-20230101183617313"></p><hr><p><strong>@PathVariable</strong></p><p><code>@PathVariable</code>注解是将方法中的参数绑定到请求URI中的模板变量上。可以通过<code>@RequestMapping</code>注解来指定URI的模板变量，然后使用<code>@PathVariable</code>注解将方法中的参数绑定到模板变量上。</p><p>特别地，<code>@PathVariable</code>注解允许我们使用value或name属性来给参数取一个别名。下面是使用此注解的一个示例：</p><p><img src="/../images/image-20230101183710807.png" alt="image-20230101183710807"></p><p>模板变量名需要使用<code>&#123; &#125;</code>进行包裹，如果方法的参数名与URI模板变量名一致，则在<code>@PathVariable</code>中就可以省略别名的定义。</p><p>下面是一个简写的示例：</p><p><img src="/../images/image-20230101183731444.png" alt="image-20230101183731444"></p><p>提示：如果参数是一个非必须的，可选的项，则可以在<code>@PathVariable</code>中设置<code>require = false</code></p><hr><p><strong>@RequestParam</strong></p><p><code>@RequestParam</code>注解用于将方法的参数与Web请求的传递的参数进行绑定。使用<code>@RequestParam</code>可以轻松的访问HTTP请求参数的值。</p><p>下面是使用该注解的代码示例：</p><p><img src="/../images/image-20230101183838260.png" alt="image-20230101183838260"></p><p>该注解的其他属性配置与<code>@PathVariable</code>的配置相同，特别的，如果传递的参数为空，还可以通过defaultValue设置一个默认值。示例代码如下：</p><p><img src="/../images/image-20230101183903004.png" alt="image-20230101183903004"></p><hr><p><strong>@Controller</strong></p><p><code>@Controller</code>是<code>@Component</code>注解的一个延伸，Spring会自动扫描并配置被该注解标注的类。此注解用于标注Spring MVC的控制器。下面是使用此注解的示例代码：</p><p><img src="/../images/image-20230101183930364.png" alt="image-20230101183930364"></p><hr><p><strong>@RestController</strong></p><p><code>@RestController</code>是在Spring 4.0开始引入的，这是一个特定的控制器注解。此注解相当于<code>@Controller</code>和<code>@ResponseBody</code>的快捷方式。当使用此注解时，不需要再在方法上使用<code>@ResponseBody</code>注解。</p><p>下面是使用此注解的示例代码：</p><p><img src="/../images/image-20230101184106015.png" alt="image-20230101184106015"></p><hr><p><strong>@ModelAttribute</strong></p><p>通过此注解，可以通过模型索引名称来访问已经存在于控制器中的model。下面是使用此注解的一个简单示例：</p><p><img src="/../images/image-20230101184149235.png" alt="image-20230101184149235"></p><p>与<code>@PathVariable</code>和<code>@RequestParam</code>注解一样，如果参数名与模型具有相同的名字，则不必指定索引名称，简写示例如下：</p><p><img src="/../images/image-20230101184219322.png" alt="image-20230101184219322"></p><p>特别地，如果使用<code>@ModelAttribute</code>对方法进行标注，Spring会将方法的返回值绑定到具体的Model上。示例如下：</p><p><img src="/../images/image-20230101184240076.png" alt="image-20230101184240076"></p><p>在Spring调用具体的处理方法之前，被<code>@ModelAttribute</code>注解标注的所有方法都将被执行。</p><hr><p><strong>@CrossOrigin</strong></p><p><code>@CrossOrigin</code>注解将为请求处理类或请求处理方法提供跨域调用支持。如果我们将此注解标注类，那么类中的所有方法都将获得支持跨域的能力。使用此注解的好处是可以微调跨域行为。使用此注解的示例如下：</p><p><img src="/../images/image-20230101184426236.png" alt="image-20230101184426236"></p><hr><p><strong>@InitBinder</strong></p><p><code>@InitBinder</code>注解用于标注初始化<strong>WebDataBinider</strong>的方法，该方法用于对Http请求传递的表单数据进行处理，如时间格式化、字符串处理等。下面是使用此注解的示例：</p><p><img src="/../images/image-20230101190158545.png" alt="image-20230101190158545"></p><h2 id="二、Spring-Bean-注解"><a href="#二、Spring-Bean-注解" class="headerlink" title="二、Spring Bean 注解"></a>二、Spring Bean 注解</h2><p>在本小节中，主要列举与Spring Bean相关的4个注解以及它们的使用方式。</p><p><strong>@ComponentScan</strong></p><p><code>@ComponentScan</code>注解用于配置Spring需要扫描的被组件注解注释的类所在的包。可以通过配置其basePackages属性或者value属性来配置需要扫描的包路径。value属性是basePackages的别名。此注解的用法如下：</p><hr><p><strong>@Component</strong></p><p>@Component注解用于标注一个普通的组件类，它没有明确的业务范围，只是通知Spring被此注解的类需要被纳入到Spring Bean容器中并进行管理。此注解的使用示例如下：</p><p><img src="/../images/image-20230101190241003.png" alt="image-20230101190241003"></p><hr><p><strong>@Service</strong></p><p><code>@Service</code>注解是<code>@Component</code>的一个延伸（特例），它用于标注业务逻辑类。与<code>@Component</code>注解一样，被此注解标注的类，会自动被Spring所管理。下面是使用<code>@Service</code>注解的示例：</p><p><img src="/../images/image-20230101190313588.png" alt="image-20230101190313588"></p><hr><p><strong>@Repository</strong></p><p><code>@Repository</code>注解也是<code>@Component</code>注解的延伸，与<code>@Component</code>注解一样，被此注解标注的类会被Spring自动管理起来，<code>@Repository</code>注解用于标注DAO层的数据持久化类。此注解的用法如下：</p><p><img src="/../images/image-20230101190340354.png" alt="image-20230101190340354"></p><h2 id="三、Spring-Dependency-Inject-与-Bean-Scops注解"><a href="#三、Spring-Dependency-Inject-与-Bean-Scops注解" class="headerlink" title="三、Spring Dependency Inject 与 Bean Scops注解"></a>三、Spring Dependency Inject 与 Bean Scops注解</h2><h3 id="Spring-DI注解"><a href="#Spring-DI注解" class="headerlink" title="Spring DI注解"></a>Spring DI注解</h3><p><strong>@DependsOn</strong></p><p><code>@DependsOn</code>注解可以配置Spring IoC容器在初始化一个Bean之前，先初始化其他的Bean对象。下面是此注解使用示例代码：</p><p><img src="/../images/640.jpeg" alt="图片"></p><hr><p><strong>@Bean</strong></p><p>@Bean注解主要的作用是告知Spring，被此注解所标注的类将需要纳入到Bean管理工厂中。@Bean注解的用法很简单，在这里，着重介绍@Bean注解中<code>initMethod</code>和<code>destroyMethod</code>的用法。示例如下：</p><p><img src="/../images/640-20230101190420869.jpeg" alt="图片"></p><h3 id="Scops注解"><a href="#Scops注解" class="headerlink" title="Scops注解"></a>Scops注解</h3><p><strong>@Scope</strong></p><p>@Scope注解可以用来定义@Component标注的类的作用范围以及@Bean所标记的类的作用范围。@Scope所限定的作用范围有：<code>singleton</code>、<code>prototype</code>、<code>request</code>、<code>session</code>、<code>globalSession</code>或者其他的自定义范围。这里以prototype为例子进行讲解。</p><p>当一个Spring Bean被声明为prototype（原型模式）时，在每次需要使用到该类的时候，Spring IoC容器都会初始化一个新的改类的实例。在定义一个Bean时，可以设置Bean的scope属性为<code>prototype：scope=“prototype”</code>,也可以使用@Scope注解设置，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Scope(value=ConfigurableBeanFactory.SCOPE_PROPTOTYPE)</span><br></pre></td></tr></table></figure><p>下面将给出两种不同的方式来使用@Scope注解，示例代码如下：</p><p><img src="/../images/640-20230101190433197.jpeg" alt="图片"></p><hr><p><strong>@Scope 单例模式</strong></p><p>当@Scope的作用范围设置成Singleton时，被此注解所标注的类只会被Spring IoC容器初始化一次。在默认情况下，Spring IoC容器所初始化的类实例都为singleton。同样的原理，此情形也有两种配置方式，示例代码如下：</p><p><img src="/../images/640.png" alt="图片"></p><h2 id="四、容器配置注解"><a href="#四、容器配置注解" class="headerlink" title="四、容器配置注解"></a>四、容器配置注解</h2><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired注解用于标记Spring将要解析和注入的依赖项。此注解可以作用在构造函数、字段和setter方法上。</p><p><strong>作用于构造函数</strong></p><p>下面是@Autowired注解标注构造函数的使用示例：</p><p><img src="/../images/640-20230101190624900.png" alt="图片"></p><hr><p><strong>作用于setter方法</strong></p><p>下面是@Autowired注解标注setter方法的示例代码：</p><p><img src="/../images/640-20230101190635336.png" alt="图片"></p><hr><p><strong>作用于字段</strong></p><p>@Autowired注解标注字段是最简单的，只需要在对应的字段上加入此注解即可，示例代码如下：</p><p><img src="/../images/640-20230101190641056.png" alt="图片"></p><h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>当系统中需要配置多个具有相同类型的bean时，@Primary可以定义这些Bean的优先级。下面将给出一个实例代码来说明这一特性：</p><p><img src="/../images/640-20230101190649206.png" alt="图片"></p><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is send DingDing method message.</span><br></pre></td></tr></table></figure><h3 id="PostConstruct与-PreDestroy"><a href="#PostConstruct与-PreDestroy" class="headerlink" title="@PostConstruct与@PreDestroy"></a>@PostConstruct与@PreDestroy</h3><p>值得注意的是，这两个注解不属于Spring,它们是源于JSR-250中的两个注解，位于<code>common-annotations.jar</code>中。@PostConstruct注解用于标注在Bean被Spring初始化之前需要执行的方法。@PreDestroy注解用于标注Bean被销毁前需要执行的方法。下面是具体的示例代码：</p><p><img src="/../images/640-20230101190715952.png" alt="图片"></p><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>当系统中存在同一类型的多个Bean时，@Autowired在进行依赖注入的时候就不知道该选择哪一个实现类进行注入。此时，我们可以使用@Qualifier注解来微调，帮助@Autowired选择正确的依赖项。下面是一个关于此注解的代码示例：</p><p><img src="/../images/640-20230101190752562.png" alt="图片"></p><h2 id="五、Spring-Boot注解"><a href="#五、Spring-Boot注解" class="headerlink" title="五、Spring Boot注解"></a><strong>五、Spring Boot注解</strong></h2><p><strong>@SpringBootApplication</strong></p><p><code>@SpringBootApplication</code>注解是一个快捷的配置注解，在被它标注的类中，可以定义一个或多个Bean，并自动触发自动配置Bean和自动扫描组件。此注解相当于<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的组合。</p><p>在Spring Boot应用程序的主类中，就使用了此注解。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">   SpringApplication.run(Application.class,args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@EnableAutoConfiguration</strong></p><p>@EnableAutoConfiguration注解用于通知Spring，根据当前类路径下引入的依赖包，自动配置与这些依赖包相关的配置项。</p><hr><p><strong>@ConditionalOnClass与@ConditionalOnMissingClass</strong></p><p>这两个注解属于类条件注解，它们根据是否存在某个类作为判断依据来决定是否要执行某些配置。下面是一个简单的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLAutoConfiguration</span> &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@ConditionalOnBean与@ConditionalOnMissingBean</strong></p><p>这两个注解属于对象条件注解，根据是否存在某个对象作为依据来决定是否要执行某些配置方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;dataSource&quot;)</span></span><br><span class="line">LocalContainerEntityManagerFactoryBean <span class="title function_">entityManagerFactory</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@ConditionalOnProperty</strong></p><p>@ConditionalOnProperty注解会根据Spring配置文件中的配置项是否满足配置要求，从而决定是否要执行被其标注的方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;alipay&quot;,havingValue=&quot;on&quot;)</span></span><br><span class="line">Alipay <span class="title function_">alipay</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Alipay</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@ConditionalOnResource</strong></p><p>此注解用于检测当某个配置文件存在使，则触发被其标注的方法，下面是使用此注解的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnResource(resources = &quot;classpath:website.properties&quot;)</span></span><br><span class="line">Properties <span class="title function_">addWebsiteProperties</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@ConditionalOnWebApplication与@ConditionalOnNotWebApplication</strong></p><p>这两个注解用于判断当前的应用程序是否是Web应用程序。如果当前应用是Web应用程序，则使用Spring WebApplicationContext,并定义其会话的生命周期。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line">HealthCheckController <span class="title function_">healthCheckController</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@ConditionalExpression</strong></p><p>此注解可以让我们控制更细粒度的基于表达式的配置条件限制。当表达式满足某个条件或者表达式为真的时候，将会执行被此注解标注的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalException(&quot;$&#123;localstore&#125; &amp;&amp; $&#123;local == &#x27;true&#x27;&#125;&quot;)</span></span><br><span class="line">LocalFileStore <span class="title function_">store</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@Conditional</strong></p><p>@Conditional注解可以控制更为复杂的配置条件。在Spring内置的条件控制注解不满足应用需求的时候，可以使用此注解定义自定义的控制条件，以达到自定义的要求。下面是使用该注解的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditioanl(CustomConditioanl.class)</span></span><br><span class="line">CustomProperties <span class="title function_">addCustomProperties</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@Before &amp;&amp; @After</strong></p><p>JUnit 4 开始使用 Java 5 中的注解（annotation），常用的几个 annotation 介绍： </p><p>@BeforeClass：针对所有测试，只执行一次，且必须为static void </p><p>@Before：初始化方法 </p><p>@Test：测试方法，在这里可以测试期望异常和超时时间 </p><p>@After：释放资源 </p><p>@AfterClass：针对所有测试，只执行一次，且必须为static void </p><p>@Ignore：忽略的测试方法  </p><p>一个单元测试用例执行顺序为： @BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass </p><p>每一个测试方法的调用顺序为： @Before –&gt; @Test –&gt; @After</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本次课程总结了Spring Boot中常见的各类型注解的使用方式，让大家能够统一的对Spring Boot常用注解有一个全面的了解。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是指一个类在一个进程中只有一个实例对象（但也不一定，比如Spring中的Bean的单例是指在一个容器中是单例的）</p><p>单例模式创建分为饿汉式和懒汉式，总共大概有8种写法。但是在开源项目中使用最多的主要有两种写法：</p><h4 id="1、静态常量"><a href="#1、静态常量" class="headerlink" title="1、静态常量"></a>1、静态常量</h4><p>静态常量方式属于饿汉式，以静态变量的方式声明对象。这种单例模式在Spring中使用的比较多，举个例子，在Spring中对于Bean的名称生成有个类AnnotationBeanNameGenerator就是单例的。</p><p><img src="/../images/image-20221225131221433.png" alt="image-20221225131221433">AnnotationBeanNameGenerator</p><h4 id="2、双重检查机制"><a href="#2、双重检查机制" class="headerlink" title="2、双重检查机制"></a>2、双重检查机制</h4><p>除了上面一种，还有一种双重检查机制在开源项目中也使用的比较多，而且在面试中也比较喜欢问。双重检查机制方式属于懒汉式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以这种方式叫双重检查机制，主要是在创建对象的时候进行了两次INSTANCE == null的判断。</p><h5 id="疑问讲解"><a href="#疑问讲解" class="headerlink" title="疑问讲解"></a>疑问讲解</h5><p>这里解释一下双重检查机制的三个疑问：</p><ul><li>外层判断null的作用</li><li>内层判断null的作用</li><li>变量使用volatile关键字修饰的作用</li></ul><p><strong>外层判断null的作用</strong>：其实就是为了减少进入同步代码块的次数，提高效率。你想一下，其实去了外层的判断其实是可以的，但是每次获取对象都需要进入同步代码块，实在是没有必要。</p><p><strong>内层判断null的作用</strong>：防止多次创建对象。假设AB同时走到同步代码块，A先抢到锁，进入代码，创建了对象，释放锁，此时B进入代码块，如果没有判断null，那么就会直接再次创建对象，那么就不是单例的了，所以需要进行判断null，防止重复创建单例对象。</p><p><strong>volatile关键字的作用</strong>：防止重排序。因为创建对象的过程不是原子，大概会分为三个步骤</p><ul><li>第一步：分配内存空间给Singleton这个对象</li><li>第二步：初始化对象</li><li>第三步：将INSTANCE变量指向Singleton这个对象内存地址</li></ul><p>假设没有使用volatile关键字发生了重排序，第二步和第三步执行过程被调换了，也就是先将INSTANCE变量指向Singleton这个对象内存地址，再初始化对象。这样在发生并发的情况下，另一个线程经过第一个if非空判断时，发现已经为不为空，就直接返回了这个对象，但是此时这个对象还未初始化，内部的属性可能都是空值，一旦被使用的话，就很有可能出现空指针这些问题。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。</p><p>上面的意思看起来很绕，其实在实际开发中，其实建造者模式使用的还是比较多的，比如有时在创建一个pojo对象时，就可以使用建造者模式来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PersonDTO</span> <span class="variable">personDTO</span> <span class="operator">=</span> PersonDTO.builder()</span><br><span class="line">        .name(<span class="string">&quot;三友的java日记&quot;</span>)</span><br><span class="line">        .age(<span class="number">18</span>)</span><br><span class="line">        .sex(<span class="number">1</span>)</span><br><span class="line">        .phone(<span class="string">&quot;188****9527&quot;</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>上面这段代码就是通过建造者模式构建了一个PersonDTO对象，所以建造者模式又被称为Budiler模式。</p><p>这种模式在创建对象的时候看起来比较优雅，当构造参数比较多的时候，适合使用建造者模式。</p><p>接下来就来看看建造者模式在开源项目中是如何运用的</p><h5 id="1、在Spring中的运用"><a href="#1、在Spring中的运用" class="headerlink" title="1、在Spring中的运用"></a>1、在Spring中的运用</h5><p>我们都知道，Spring在创建Bean之前，会将每个Bean的声明封装成对应的一个BeanDefinition，而BeanDefinition会封装很多属性，所以Spring为了更加优雅地创建BeanDefinition，就提供了BeanDefinitionBuilder这个建造者类。</p><p><img src="/../images/image-20221225131235339.png" alt="image-20221225131235339">BeanDefinitionBuilder</p><blockquote><p><a href="https://m.runoob.com/design-pattern/builder-pattern.html?ivk_sa=1024320u">https://m.runoob.com/design-pattern/builder-pattern.html?ivk_sa=1024320u</a></p></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式在开源项目中也使用的非常多，具体的实现大概可以细分为三种：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式，就跟名字一样，的确很简单。比如说，现在有个动物接口Animal，具体的实现有猫Cat、狗Dog等等，而每个具体的动物对象创建过程很复杂，有各种各样地步骤，此时就可以使用简单工厂来封装对象的创建过程，调用者不需要关心对象是如何具体创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleAnimalFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">(String animalType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;cat&quot;</span>.equals(animalType)) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">            <span class="comment">//一系列复杂操作</span></span><br><span class="line">            <span class="keyword">return</span> cat;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;dog&quot;</span>.equals(animalType)) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            <span class="comment">//一系列复杂操作</span></span><br><span class="line">            <span class="keyword">return</span> dog;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;animalType=&quot;</span> + animalType + <span class="string">&quot;无法创建对应对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要使用这些对象，调用者就可以直接通过简单工厂创建就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleAnimalFactory</span> <span class="variable">animalFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAnimalFactory</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> animalFactory.createAnimal(<span class="string">&quot;cat&quot;</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，一般来说如果每个动物对象的创建只需要简单地new一下就行了，那么其实就无需使用工厂模式，工厂模式适合对象创建过程复杂的场景。</p><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>上面说的简单工厂模式看起来没啥问题，但是还是违反了七大设计原则的OCP原则，也就是开闭原则。所谓的开闭原则就是对修改关闭，对扩展开放。</p><p>什么叫对修改关闭？就是尽可能不修改的意思。就拿上面的例子来说，如果现在新增了一种动物兔子，那么createAnimal方法就得修改，增加一种类型的判断，那么就此时就出现了修改代码的行为，也就违反了对修改关闭的原则。</p><p>所以解决简单工厂模式违反开闭原则的问题，就可以使用工厂方法模式来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    Animal <span class="title function_">createAnimal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小猫实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatFactory</span> <span class="keyword">implements</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">//一系列复杂操作</span></span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小狗实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogFactory</span> <span class="keyword">implements</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//一系列复杂操作</span></span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式就是工厂方法模式。他将动物工厂提取成一个接口AnimalFactory，具体每个动物都各自实现这个接口，每种动物都有各自的创建工厂，如果调用者需要创建动物，就可以通过各自的工厂来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnimalFactory</span> <span class="variable">animalFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CatFactory</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> animalFactory.createAnimal();</span><br></pre></td></tr></table></figure><p>此时假设需要新增一个动物兔子，那么只需要实现AnimalFactory接口就行，对于原来的猫和狗的实现，其实代码是不需要修改的，遵守了对修改关闭的原则，同时由于是对扩展开放，实现接口就是扩展的意思，那么也就符合扩展开放的原则。</p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>工厂方法模式其实是创建一个产品的工厂，比如上面的例子中，AnimalFactory其实只创建动物这一个产品。而抽象工厂模式特点就是创建一系列产品，比如说，不同的动物吃的东西是不一样的，那么就可以加入食物这个产品，通过抽象工厂模式来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Animal <span class="title function_">createAnimal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Food <span class="title function_">createFood</span><span class="params">()</span>;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在动物工厂中，新增了创建食物的接口，小狗小猫的工厂去实现这个接口，创建狗粮和猫粮，这里就不去写了。</p><h5 id="1、工厂模式在Mybatis的运用"><a href="#1、工厂模式在Mybatis的运用" class="headerlink" title="1、工厂模式在Mybatis的运用"></a>1、工厂模式在Mybatis的运用</h5><p>在Mybatis中，当需要调用Mapper接口执行sql的时候，需要先获取到SqlSession，通过SqlSession再获取到Mapper接口的动态代理对象，而SqlSession的构造过程比较复杂，所以就提供了SqlSessionFactory工厂类来封装SqlSession的创建过程。</p><p><img src="/../images/image-20221225131249726.png" alt="image-20221225131249726">SqlSessionFactory及默认实现DefaultSqlSessionFactory</p><p>对于使用者来说，只需要通过SqlSessionFactory来获取到SqlSession，而无需关心SqlSession是如何创建的。</p><h5 id="2、工厂模式在Spring中的运用"><a href="#2、工厂模式在Spring中的运用" class="headerlink" title="2、工厂模式在Spring中的运用"></a>2、工厂模式在Spring中的运用</h5><p>我们知道Spring中的Bean是通过BeanFactory创建的。</p><p><img src="/../images/image-20221225131302047.png" alt="image-20221225131302047"></p><p>BeanFactory就是Bean生成的工厂。一个Spring Bean在生成过程中会经历复杂的一个生命周期，而这些生命周期对于使用者来说是无需关心的，所以就可以将Bean创建过程的逻辑给封装起来，提取出一个Bean的工厂。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式也比较常见，就比如说在Spring源码中就有很多地方都使用到了策略模式。</p><p>在讲策略模式是什么之前先来举个例子，这个例子我在之前的<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247530835&idx=1&sn=6bc43645c2249eb5b0ee9a9fca5077b7&chksm=cea13698f9d6bf8e54e9c9207e9525ecf2bde92b9b68d7a9765b44ffdb49b67162745c39c716&token=9220217&lang=zh_CN&scene=21#wechat_redirect">《写出漂亮代码的45个小技巧》</a>文章提到过。</p><p>假设现在有一个需求，需要将消息推送到不同的平台。</p><p>最简单的做法其实就是使用if else来做判断就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyMessage</span><span class="params">(User user, String content, <span class="type">int</span> notifyType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (notifyType == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//调用短信通知的api发送短信</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (notifyType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//调用app通知的api发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不同的平台类型进行判断，调用对应的api发送消息。</p><p>虽然这样能实现功能，但是跟上面的提到的简单工厂的问题是一样的，同样违反了开闭原则。当需要增加一种平台类型，比如邮件通知，那么就得修改notifyMessage的方法，再次进行else if的判断，然后调用发送邮件的邮件发送消息。</p><p>此时就可以使用策略模式来优化了。</p><p>首先设计一个策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageNotifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持改类型的通知的方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> notifyType 0:短信 1:app</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(<span class="type">int</span> notifyType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(User user, String content)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短信通知实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSMessageNotifier</span> <span class="keyword">implements</span> <span class="title class_">MessageNotifier</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(<span class="type">int</span> notifyType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> notifyType == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(User user, String content)</span> &#123;</span><br><span class="line">        <span class="comment">//调用短信通知的api发送短信</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app通知实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppMessageNotifier</span> <span class="keyword">implements</span> <span class="title class_">MessageNotifier</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(<span class="type">int</span> notifyType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> notifyType == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(User user, String content)</span> &#123;</span><br><span class="line">       <span class="comment">//调用通知app通知的api</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后notifyMessage的实现只需要要循环调用所有的MessageNotifier的support方法，一旦support方法返回true，说明当前MessageNotifier支持该类的消息发送，最后再调用notify发送消息就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MessageNotifier&gt; messageNotifiers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyMessage</span><span class="params">(User user, String content, <span class="type">int</span> notifyType)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (MessageNotifier messageNotifier : messageNotifiers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (messageNotifier.support(notifyType)) &#123;</span><br><span class="line">            messageNotifier.notify(user, content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果现在需要支持通过邮件通知，只需要实现MessageNotifier接口，注入到Spring容器就行，其余的代码根本不需要有任何变动。</p><p>到这其实可以更好的理解策略模式了。就拿上面举的例子来说，短信通知，app通知等其实都是发送消息一种策略，而策略模式就是需要将这些策略进行封装，抽取共性，使这些策略之间相互替换。</p><h4 id="策略模式在SpringMVC中的运用"><a href="#策略模式在SpringMVC中的运用" class="headerlink" title="策略模式在SpringMVC中的运用"></a>策略模式在SpringMVC中的运用</h4><h5 id="1、对接口方法参数的处理"><a href="#1、对接口方法参数的处理" class="headerlink" title="1、对接口方法参数的处理"></a>1、对接口方法参数的处理</h5><p>比如说，我们经常在写接口的时候，会使用到了@PathVariable、@RequestParam、@RequestBody等注解，一旦我们使用了注解，SpringMVC会处理注解，从请求中获取到参数，然后再调用接口传递过来，而这个过程，就使用到了策略模式。</p><p>对于这类参数的解析，SpringMVC提供了一个策略接口HandlerMethodArgumentResolver</p><p><img src="/../images/image-20221225131325869.png" alt="image-20221225131325869">HandlerMethodArgumentResolver</p><p>这个接口的定义就跟我们上面定义的差不多，不同的参数处理只需要实现这个解决就行，比如上面提到的几个注解，都有对应的实现。</p><p>比如处理@RequestParam注解的RequestParamMethodArgumentResolver的实现。</p><p><img src="/../images/image-20221225131338351.png" alt="image-20221225131338351">RequestParamMethodArgumentResolver</p><p>当然还有其它很多的实现，如果想知道各种注解处理的过程，只需要找到对应的实现类就行了。</p><h5 id="2、对接口返回值的处理"><a href="#2、对接口返回值的处理" class="headerlink" title="2、对接口返回值的处理"></a>2、对接口返回值的处理</h5><p>同样，SpringMVC对于返回值的处理也是基于策略模式来实现的。</p><p><img src="/../images/image-20221225131349308.png" alt="image-20221225131349308">HandlerMethodReturnValueHandler</p><p>HandlerMethodReturnValueHandler接口定义跟上面都是同一种套路。</p><p>比如说，常见的对于@ResponseBody注解处理的实现RequestResponseBodyMethodProcessor。</p><p><img src="/../images/image-20221225131400617.png" alt="image-20221225131400617">ResponseBody注解处理的实现RequestResponseBodyMethodProcessor</p><p>同样，HandlerMethodReturnValueHandler的实现也有很多，这里就不再举例了。</p><p>策略模式在Spring的运用远不止这两处，就比如我在<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247530447&idx=1&sn=87ea04d63cc101761a3eadadbf8966ea&chksm=cea13804f9d6b112e16fb0e73d93f270f20c5294270285fffa486e5a21c26b2bf622aaa3340f&token=9220217&lang=zh_CN&scene=21#wechat_redirect">《三万字盘点Spring/Boot的那些常用扩展点》</a>文章提到过对于配置文件的加载PropertySourceLoader也是策略模式的运用。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式是指，在父类中定义一个操作中的框架，而操作步骤的具体实现交由子类做。其核心思想就是，对于功能实现的顺序步骤是一定的，但是具体每一步如何实现交由子类决定。</p><p>比如说，对于旅游来说，一般有以下几个步骤：</p><ul><li>做攻略，选择目的地</li><li>收拾行李</li><li>乘坐交通工具去目的地</li><li>玩耍、拍照</li><li>乘坐交通工具去返回</li></ul><p>但是对于去哪，收拾什么东西都，乘坐什么交通工具，都是由具体某个旅行来决定。</p><p>那么对于旅游这个过程使用模板方法模式翻译成代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Travel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//做攻略</span></span><br><span class="line">        makePlan();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收拾行李</span></span><br><span class="line">        packUp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去目的地</span></span><br><span class="line">        toDestination();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//玩耍、拍照</span></span><br><span class="line">        play();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//乘坐交通工具去返回</span></span><br><span class="line">        backHome();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makePlan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">packUp</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">toDestination</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">backHome</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于某次旅行来说，只需要重写每个步骤该做的事就行，比如说这次可以选择去杭州西湖，下次可以去长城，但是对于旅行过程来说是不变了，对于调用者来说，只需要调用暴露的travel方法就行。</p><p>可能这说的还是比较抽象，我再举两个模板方法模式在源码中实现的例子。</p><h4 id="模板方法模式在源码中的使用"><a href="#模板方法模式在源码中的使用" class="headerlink" title="模板方法模式在源码中的使用"></a>模板方法模式在源码中的使用</h4><h5 id="1、模板方法模式在HashMap中的使用"><a href="#1、模板方法模式在HashMap中的使用" class="headerlink" title="1、模板方法模式在HashMap中的使用"></a>1、模板方法模式在HashMap中的使用</h5><p>HashMap我们都很熟悉，可以通过put方法存元素，并且在元素添加成功之后，会调用一下afterNodeInsertion方法。</p><p><img src="/../images/image-20221225131416617.png" alt="image-20221225131416617"></p><p>而afterNodeInsertion其实是在HashMap中是空实现，什么事都没干。</p><p><img src="/../images/image-20221225131429048.png" alt="image-20221225131429048">afterNodeInsertion</p><p>这其实就是模板方法模式。HashMap定义了一个流程，那就是当元素成功添加之后会调用afterNodeInsertion，子类如果需要在元素添加之后做什么事，那么重写afterNodeInsertion就行。</p><p>正巧，JDK中的LinkedHashMap重写了这个方法。</p><p><img src="/../images/image-20221225131441285.png" alt="image-20221225131441285"></p><p>而这段代码主要干的一件事就是可能会移除最老的元素，至于到底会不会移除，得看if是否成立。</p><p>添加元素移除最老的元素，基于这种特性其实可以实现LRU算法，比如Mybatis的LruCache就是基于LinkedHashMap实现的，有兴趣的可以扒扒源码，这里就不再展开讲了。</p><h5 id="2、模板方法模式在Spring中的运用"><a href="#2、模板方法模式在Spring中的运用" class="headerlink" title="2、模板方法模式在Spring中的运用"></a>2、模板方法模式在Spring中的运用</h5><p>我们都知道，在Spring中，ApplicationContext在使用之前需要调用一下refresh方法，而refresh方法就定义了整个容器刷新的执行流程代码。</p><p><img src="/../images/image-20221225131457674.png" alt="image-20221225131457674">refresh方法部分截图</p><p>在整个刷新过程有一个onRefresh方法</p><p><img src="/../images/image-20221225131510614.png" alt="image-20221225131510614">onRefresh方法</p><p>而onRefresh方法默认是没有做任何事，并且在注释上有清楚两个单词Template method，翻译过来就是模板方法的意思，所以onRefresh就是一个模板方法，并且方法内部的注释也表明了，这个方法是为了子类提供的。</p><p>在Web环境下，子类会重写这个方法，然后创建一个Web服务器。</p><p><img src="/../images/image-20221225131521073.png" alt="image-20221225131521073"></p><h6 id="3、模板方法模式在Mybatis中的使用"><a href="#3、模板方法模式在Mybatis中的使用" class="headerlink" title="3、模板方法模式在Mybatis中的使用"></a>3、模板方法模式在Mybatis中的使用</h6><p>在Mybatis中，是使用Executor执行Sql的。</p><p><img src="/../images/image-20221225131532212.png" alt="image-20221225131532212">Executor</p><p>而Mybatis一级缓存就在Executor的抽象实现中BaseExecutor实现的。如图所示，红圈就是一级缓存</p><p><img src="/../images/image-20221225131542152.png" alt="image-20221225131542152">BaseExecutor</p><p>比如在查询的时候，如果一级缓存有，那么就处理缓存的数据，没有的话就调用queryFromDatabase从数据库查</p><p><img src="/../images/image-20221225131555133.png" alt="image-20221225131555133"></p><p>queryFromDatabase会调用doQuery方法从数据库查数据，然后放入一级缓存中。</p><p><img src="/../images/image-20221225131604176.png" alt="image-20221225131604176"></p><p>而doQuery是个抽象方法</p><p><img src="/../images/image-20221225131613607.png" alt="image-20221225131613607"></p><p>所以doQuery其实就是一个模板方法，需要子类真正实现从数据库中查询数据，所以这里就使用了模板方法模式。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，由该链上的某一个对象或者某几个对象决定处理此请求，每个对象在整个处理过程中值扮演一个小小的角色。</p><p>举个例子，现在有个请假的审批流程，根据请假的人的级别审批到的领导不同，比如有有组长、主管、HR、分管经理等等。</p><p>先需要定义一个处理抽象类，抽象类有个下一个处理对象的引用，提供了抽象处理方法，还有一个对下一个处理对象的调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApprovalHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 责任链中的下一个处理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ApprovalHandler next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置下一个处理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> approvalHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextHandler</span><span class="params">(ApprovalHandler approvalHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = approvalHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> approvalContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">approval</span><span class="params">(ApprovalContext approvalContext)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用下一个处理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> approvalContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeNext</span><span class="params">(ApprovalContext approvalContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            next.approval(approvalContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几种审批人的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组长审批实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeaderApprovalHandler</span> <span class="keyword">extends</span> <span class="title class_">ApprovalHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">approval</span><span class="params">(ApprovalContext approvalContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;组长审批&quot;</span>);</span><br><span class="line">        <span class="comment">//调用下一个处理对象进行处理</span></span><br><span class="line">        invokeNext(approvalContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主管审批实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectorApprovalHandler</span> <span class="keyword">extends</span> <span class="title class_">ApprovalHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">approval</span><span class="params">(ApprovalContext approvalContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主管审批&quot;</span>);</span><br><span class="line">        <span class="comment">//调用下一个处理对象进行处理</span></span><br><span class="line">        invokeNext(approvalContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hr审批实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HrApprovalHandler</span> <span class="keyword">extends</span> <span class="title class_">ApprovalHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">approval</span><span class="params">(ApprovalContext approvalContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hr审批&quot;</span>);</span><br><span class="line">        <span class="comment">//调用下一个处理对象进行处理</span></span><br><span class="line">        invokeNext(approvalContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这几个实现之后，接下来就需要对对象进行组装，组成一个链条，比如在Spring中就可以这么玩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApprovalHandlerChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GroupLeaderApprovalHandler groupLeaderApprovalHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DirectorApprovalHandler directorApprovalHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HrApprovalHandler hrApprovalHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ApprovalHandler <span class="title function_">getChain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//组长处理完下一个处理对象是主管</span></span><br><span class="line">        groupLeaderApprovalHandler.nextHandler(directorApprovalHandler);</span><br><span class="line">        <span class="comment">//主管处理完下一个处理对象是hr</span></span><br><span class="line">        directorApprovalHandler.nextHandler(hrApprovalHandler);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回组长，这样就从组长开始审批，一条链就完成了</span></span><br><span class="line">        <span class="keyword">return</span> groupLeaderApprovalHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后对于调用方而言，只需要获取到链条，开始处理就行。</p><p>一旦后面出现需要增加或者减少审批人，只需要调整链条中的节点就行，对于调用者来说是无感知的。</p><h4 id="责任链模式在开源项目中的使用"><a href="#责任链模式在开源项目中的使用" class="headerlink" title="责任链模式在开源项目中的使用"></a>责任链模式在开源项目中的使用</h4><h5 id="1、在SpringMVC中的使用"><a href="#1、在SpringMVC中的使用" class="headerlink" title="1、在SpringMVC中的使用"></a>1、在SpringMVC中的使用</h5><p>在SpringMVC中，可以通过使用HandlerInterceptor对每个请求进行拦截。</p><p>HandlerInterceptor</p><p>而HandlerInterceptor其实就使用到了责任链模式，但是这种责任链模式的写法跟上面举的例子写法不太一样。</p><p>对于HandlerInterceptor的调用是在HandlerExecutionChain中完成的。</p><p>HandlerExecutionChain</p><p>比如说，对于请求处理前的拦截，就在是这样调用的。</p><p>其实就是循环遍历每个HandlerInterceptor，调用preHandle方法。</p><h5 id="2、在Sentinel中的使用"><a href="#2、在Sentinel中的使用" class="headerlink" title="2、在Sentinel中的使用"></a>2、在Sentinel中的使用</h5><p>Sentinel是阿里开源的一个流量治理组件，而Sentinel核心逻辑的执行其实就是一条责任链。</p><p>在Sentinel中，有个核心抽象类AbstractLinkedProcessorSlot</p><p>AbstractLinkedProcessorSlot</p><p>这个组件内部也维护了下一个节点对象，这个类扮演的角色跟例子中的ApprovalHandler类是一样的，写法也比较相似。这个组件有很多实现</p><p>比如有比较核心的几个实现</p><ul><li>DegradeSlot：熔断降级的实现</li><li>FlowSlot：流量控制的实现</li><li>StatisticSlot：统计的实现，比如统计请求成功的次数、异常次数，为限流提供数据来源</li><li>SystemSlot：根据系统规则来进行流量控制</li></ul><p>整个链条的组装的实现是由DefaultSlotChainBuilder实现的</p><p>DefaultSlotChainBuilder</p><p>并且内部是使用了SPI机制来加载每个处理节点</p><p>所以，如果你想自定一些处理逻辑，就可以基于SPI机制来扩展。</p><p>除了上面的例子，比如Gateway网关、Dubbo、MyBatis等等框架中都有责任链模式的身影，所以责任链模式使用的还是比较多的。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式也是开源项目中很常见的使用的一种设计模式，这种模式可以在不改变原有代码的情况下增加功能。</p><p>举个例子，比如现在有个PersonService接口和它的实现类PersonServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">savePerson</span><span class="params">(PersonDTO person)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PersonService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePerson</span><span class="params">(PersonDTO person)</span> &#123;</span><br><span class="line">        <span class="comment">//保存人员信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类刚开始运行的好好的，但是突然之前不知道咋回事了，有报错，需要追寻入参，所以此时就可以这么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePerson</span><span class="params">(PersonDTO person)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;savePerson接口入参:&#123;&#125;&quot;</span>, JSON.toJSONString(person));</span><br><span class="line">        <span class="comment">//保存人员信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写，就修改了代码，万一以后不需要打印日志了呢，岂不是又要修改代码，不符和之前说的开闭原则，那么怎么写呢？可以这么玩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PersonService</span> <span class="variable">personService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePerson</span><span class="params">(PersonDTO person)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;savePerson接口入参:&#123;&#125;&quot;</span>, JSON.toJSONString(person));</span><br><span class="line">        personService.savePerson(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现一个代理类PersonServiceProxy，对PersonServiceImpl进行代理，这个代理类干的事就是打印日志，最后调用PersonServiceImpl进行人员信息的保存，这就是代理模式。</p><p>当需要打印日志就使用PersonServiceProxy，不需要打印日志就使用PersonServiceImpl，这样就行了，不需要改原有代码的实现。</p><p>讲到了代理模式，就不得不提一下Spring AOP，Spring AOP其实跟静态代理很像，最终其实也是调用目标对象的方法，只不过是动态生成的，这里就不展开讲解了。</p><h5 id="代理模式在Mybtais中的使用"><a href="#代理模式在Mybtais中的使用" class="headerlink" title="代理模式在Mybtais中的使用"></a>代理模式在Mybtais中的使用</h5><p>前面在说模板方法模式的时候，举了一个BaseExecutor使用到了模板方法模式的例子，并且在BaseExecutor这里面还完成了一级缓存的操作。</p><p>其实不光是一级缓存是通过Executor实现的，二级缓存其实也是，只不过不在BaseExecutor里面实现，而是在CachingExecutor中实现的。</p><p>CachingExecutor</p><p>CachingExecutor中内部有一个Executor类型的属性delegate，delegate单词的意思就是代理的意思，所以CachingExecutor显然就是一个代理类，这里就使用到了代理模式。</p><p>CachingExecutor的实现原理其实很简单，先从二级缓存查，查不到就通过被代理的对象查找数据，而被代理的Executor在Mybatis中默认使用的是SimpleExecutor实现，SimpleExecutor继承自BaseExecutor。</p><p>这里思考一下二级缓存为什么不像一级缓存一样直接写到BaseExecutor中？</p><p>这里我猜测一下是为了减少耦合。</p><p>我们知道Mybatis的一级缓存默认是开启的，一级缓存写在BaseExecutor中的话，那么只要是继承了BaseExecutor，就拥有了一级缓存的能力。</p><p>但二级缓存默认是不开启的，如果写在BaseExecutor中，讲道理也是可以的，但不符和单一职责的原则，类的功能过多，同时会耦合很多判断代码，比如开启二级缓存走什么逻辑，不开启二级缓存走什么逻辑。而使用代理模式很好的解决了这一问题，只需要在创建的Executor的时候判断是否开启二级缓存，开启的话就用CachingExecutor代理一下，不开启的话老老实实返回未被代理的对象就行，默认是SimpleExecutor。</p><p>如图所示，是构建Executor对象的源码，一旦开启了二级缓存，就会将前面创建的Executor进行代理，构建一个CachingExecutor返回。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作，将一个类的接口转换成客户希望的另一个接口。</p><p>举个生活中的例子，比如手机充电器接口类型有USB TypeC接口和Micro USB接口等。现在需要给一个Micro USB接口的手机充电，但是现在只有USB TypeC接口的充电器，这怎么办呢？</p><p>其实一般可以弄个一个USB TypeC转Micro USB接口的转接头，这样就可以给Micro USB接口手机充电了，代码如下</p><p>USBTypeC接口充电</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USBTypeC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chargeTypeC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启充电了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MicroUSB接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MicroUSB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配实现，最后是调用USBTypeC接口来充电</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroUSBAdapter</span> <span class="keyword">implements</span> <span class="title class_">MicroUSB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">USBTypeC</span> <span class="variable">usbTypeC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USBTypeC</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用usb来充电</span></span><br><span class="line">        usbTypeC.chargeTypeC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方然除了上面这种写法，还有一种继承的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroUSBAdapter</span> <span class="keyword">extends</span> <span class="title class_">USBTypeC</span> <span class="keyword">implements</span> <span class="title class_">MicroUSB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用usb来充电</span></span><br><span class="line">        <span class="built_in">this</span>.chargeTypeC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种写法主要是继承和组合（聚合）的区别。</p><p>这样就可以通过适配器（转接头）就可以实现USBTypeC给MicroUSB接口充电。</p><h5 id="适配器模式在日志中的使用"><a href="#适配器模式在日志中的使用" class="headerlink" title="适配器模式在日志中的使用"></a>适配器模式在日志中的使用</h5><p>在日常开发中，日志是必不可少的，可以帮助我们快速快速定位问题，但是日志框架比较多，比如Slf4j、Log4j等等，一般同一系统都使用一种日志框架。</p><p>但是像Mybatis这种框架来说，它本身在运行的过程中也需要产生日志，但是Mybatis框架在设计的时候，无法知道项目中具体使用的是什么日志框架，所以只能适配各种日志框架，项目中使用什么框架，Mybatis就使用什么框架。</p><p>为此Mybatis提供一个Log接口</p><p><img src="/../images/image-20221225131631041.png" alt="image-20221225131631041"></p><p>而不同的日志框架，只需要适配这个接口就可以了</p><p><img src="/../images/image-20221225131641350.png" alt="image-20221225131641350">Slf4jLoggerImpl</p><p>就拿Slf4j的实现来看，内部依赖了一个Slf4j框架中的Logger对象，最后所有日志的打印都是通过Slf4j框架中的Logger对象来实现的。</p><p>此外，Mybatis还提供了如下的一些实现</p><p><img src="/../images/image-20221225131652837.png" alt="image-20221225131652837"></p><p>这样，Mybatis在需要打印日志的时候，只需要从Mybatis自己的LogFactory中获取到Log对象就行，至于最终获取到的是什么Log实现，由最终项目中使用日志框架来决定。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。</p><p>这是什么意思呢，举个例子来说，假设发生了火灾，可能需要打119、救人，那么就可以基于观察者模式来实现，打119、救人的操作只需要观察火灾的发生，一旦发生，就触发相应的逻辑。</p><p><img src="/../images/image-20221225131702109.png" alt="image-20221225131702109"></p><p>观察者的核心优点就是观察者和被观察者是解耦合的。就拿上面的例子来说，火灾事件（被观察者）根本不关系有几个监听器（观察者），当以后需要有变动，只需要扩展监听器就行，对于事件的发布者和其它监听器是无需做任何改变的。</p><p>观察者模式实现起来比较复杂，这里我举一下Spring事件的例子来说明一下。</p><h5 id="观察者模式在Spring事件中的运用"><a href="#观察者模式在Spring事件中的运用" class="headerlink" title="观察者模式在Spring事件中的运用"></a>观察者模式在Spring事件中的运用</h5><p>Spring事件，就是Spring基于观察者模式实现的一套API，如果有不知道不知道Spring事件的小伙伴，可以看看<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247530447&idx=1&sn=87ea04d63cc101761a3eadadbf8966ea&chksm=cea13804f9d6b112e16fb0e73d93f270f20c5294270285fffa486e5a21c26b2bf622aaa3340f&token=9220217&lang=zh_CN&scene=21#wechat_redirect">《三万字盘点Spring/Boot的那些常用扩展点》</a>这篇文章，里面有对Spring事件的详细介绍，这里就不对使用进行介绍了。</p><p>Spring事件的实现比较简单，其实就是当Bean在生成完成之后，会将所有的ApplicationListener接口实现（监听器）添加到ApplicationEventMulticaster中。</p><p>ApplicationEventMulticaster可以理解为一个调度中心的作用，可以将事件通知给监听器，触发监听器的执行。</p><p><img src="/../images/image-20221225131712519.png" alt="image-20221225131712519">ApplicationEventMulticaster可以理解为一个总线</p><p>retrieverCache中存储了事件类型和对应监听器的缓存。当发布事件的时候，会通过事件的类型找到对应的监听器，然后循环调用监听器。</p><p><img src="/../images/image-20221225131722555.png" alt="image-20221225131722555"></p><p>所以，Spring的观察者模式实现的其实也不复杂。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过对设计模式的讲解加源码举例的方式介绍了9种在代码设计中常用的设计模式：</p><ul><li>单例模式</li><li>建造者模式</li><li>工厂模式</li><li>策略模式</li><li>模板方法模式</li><li>责任链模式</li><li>代理模式</li><li>适配器模式</li><li>观察者模式</li></ul><p>其实这些设计模式不仅在源码中常见在平时工作中也是可以经常使用到的。</p><p>设计模式其实还是一种思想，或者是套路性的东西，至于设计模式具体怎么用、如何用、代码如何写还得依靠具体的场景来进行灵活的判断。</p><p>最后，本文又是前前后后花了一周多的时间完成，如果对你有点帮助，还请帮忙点赞、在看、转发、非常感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Localhost详解</title>
      <link href="/2022/12/25/Localhost%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/12/25/Localhost%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Localhost-amp-127-0-0-1"><a href="#Localhost-amp-127-0-0-1" class="headerlink" title="Localhost &amp; 127.0.0.1"></a>Localhost &amp; 127.0.0.1</h1><p>你<strong>女神爱不爱你</strong>，你问她，她可能不会告诉你。</p><p>但<strong>网通不通</strong>，你 <code>ping</code> 一下就知道了。</p><p>可能看到标题，你就知道答案了，但是你了解背后的原因吗？</p><p>那如果把 <code>127.0.0.1</code> 换成 <code>0.0.0.0</code> 或 <code>localhost</code> 会怎么样呢？你知道这几个<code>IP</code>有什么区别吗？</p><p>以前面试的时候就遇到过这个问题，大家看个动图了解下面试官和我当时的场景，求当时我的心里阴影面积。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnmz3VSM4JH6FE0VFtydTmORTBibRrFfn1mfX9SU1hciciahTZdCFfDRRdasytF7NLattxdibdXcp8VOWA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>话不多说，我们直接开车。</p><p>拔掉网线，断网。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnkr3eLdxxIK0eujAOibyGS3aSoMibKbQFRGpTqNbMaaPUxY1icSvhv0rel4R4O3ib99hQdJ1P7AYHBplQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后在控制台输入<code>ping 127.0.0.1</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ping 127.0.0.1</span><br><span class="line">PING 127.0.0.1 (127.0.0.1): 56 data bytes</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.080 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.093 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.074 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.079 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.079 ms</span><br><span class="line">^C</span><br><span class="line">--- 127.0.0.1 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.074/0.081/0.093/0.006 ms</span><br></pre></td></tr></table></figure><p>说明，拔了网线，<code>ping 127.0.0.1</code> 是<strong>能ping通的</strong>。</p><p>其实这篇文章看到这里，标题前半个问题已经被回答了。但是我们可以再想深一点。</p><p>为什么断网了还能 <code>ping</code> 通 <code>127.0.0.1</code> 呢？</p><p><strong>这能说明你不用交网费就能上网吗？</strong></p><p><strong>不能。</strong></p><p>首先我们需要进入基础科普环节。</p><p>不懂的同学看了就懂了，懂的看了就当查漏补缺吧。</p><h3 id="什么是127-0-0-1"><a href="#什么是127-0-0-1" class="headerlink" title="什么是127.0.0.1"></a>什么是127.0.0.1</h3><p>首先，这是个 <code>IPV4</code> 地址。</p><p><code>IPV4</code> 地址有 <code>32</code> 位，一个字节有 <code>8</code> 位，共 <code>4</code> 个字节。</p><p>其中<strong>127 开头的都属于回环地址</strong>，也是 <code>IPV4</code> 的特殊地址，没什么道理，就是人为规定的。</p><p>而<code>127.0.0.1</code>是<strong>众多</strong>回环地址中的一个。之所以不是 <code>127.0.0.2</code> ，而是 <code>127.0.0.1</code>，是因为源码里就是这么定义的，也没什么道理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Address to loopback in software to local host.  */</span><br><span class="line">#define    INADDR_LOOPBACK     0x7f000001  /* 127.0.0.1   */</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221225125054345.png" alt="image-20221225125054345"></p><p><code>IPv4</code> 的地址是 <code>32</code> 位的，2的32次方，大概是<code>40+亿</code>。地球光人口就76亿了，40亿IP这点量，<strong>塞牙缝都不够</strong>，实际上<strong>IP也确实用完</strong>了。</p><p>所以就有了<code>IPV6</code>， <code>IPv6</code> 的地址是 <code>128</code> 位的，大概是2的128次方≈<strong>10的38次方</strong>。据说地球的沙子数量大概是 <strong>10的23次方</strong>，所以IPV6的IP可以认为用不完。</p><p>IPV4以8位一组，每组之间用 <strong>.</strong> 号隔开。</p><p>IPV6就以16位为一组，每组之间用 <strong>:</strong> 号隔开。如果全是0，那么可以省略不写。</p><p><img src="/../images/image-20221225125109980.png" alt="image-20221225125109980">ipv6回环地址</p><p>在IPV4下的回环地址是 <code>127.0.0.1</code>，在<code>IPV6</code>下，表达为 <code>::1</code> 。中间把<strong>连续的0</strong>给省略了，之所以不是<strong>7个 冒号</strong>，而是<strong>2个冒号:</strong> ， 是因为一个 IPV6 地址中<strong>只允许出现⼀次两个连续的冒号</strong>。</p><blockquote><p>多说一句：在IPV4下用的是 <strong>ping 127.0.0.1</strong> 命令。在IPV6下用的是 <strong>ping6  ::1</strong> 命令。</p></blockquote><h3 id="什么是-ping"><a href="#什么是-ping" class="headerlink" title="什么是 ping"></a>什么是 ping</h3><p>ping 是应用层命令，可以理解为它跟游戏或者聊天软件属于同一层。只不过聊天软件可以收发消息，还能点个赞什么的，有很多复杂的功能。而 ping 作为一个小软件，它的功能比较简单，就是<strong>尝试</strong>发送一个小小的消息到目标机器上，判断目的机器是否<strong>可达</strong>，其实也就是判断目标机器网络是否能连通。</p><p>ping应用的底层，用的是网络层的<strong>ICMP协议</strong>。</p><p><img src="/../images/image-20221225125123739.png" alt="image-20221225125123739">IP和ICMP和Ping所在分层</p><p>虽然ICMP协议和IP协议<strong>都属于网络层协议</strong>，但其实<strong>ICMP也是利用了IP协议进行消息的传输</strong>。</p><p><img src="/../images/image-20221225125134840.png" alt="image-20221225125134840">ip和icmp的关系</p><p>所以，大家在这里完全可以简单的理解为 ping 某个IP 就是往某个IP地址发个消息。</p><h3 id="TCP发数据和ping的区别"><a href="#TCP发数据和ping的区别" class="headerlink" title="TCP发数据和ping的区别"></a>TCP发数据和ping的区别</h3><p>一般情况下，我们会使用 TCP 进行网络数据传输，那么我们可以看下它和 ping 的区别。</p><p><img src="/../images/image-20221225125205127.png" alt="image-20221225125205127"></p><p>ping和普通发消息的关系</p><p>ping和其他应用层软件都属于<strong>应用层</strong>。</p><p>那么我们横向对比一下，比方说聊天软件，如果用的是TCP的方式去发送消息。</p><p>为了发送消息，那就得先知道往哪发。linux里万物皆文件，那你要发消息的目的地，也是个文件，这里就引出了socket 的概念。</p><p>要使用 <code>socket</code> , 那么首先需要创建它。</p><p>在 TCP 传输中创建的方式是  <code>socket(AF_INET, SOCK_STREAM, 0);</code>，其中 <code>AF_INET</code> 表示将使用 IPV4 里 <strong>host:port</strong> 的方式去解析待会你输入的网络地址。<code>SOCK_STREAM</code> 是指使用面向字节流的 TCP 协议，<strong>工作在传输层</strong>。</p><p>创建好了 <code>socket</code> 之后，就可以愉快的把要传输的数据写到这个文件里。调用 socket 的<code>sendto</code>接口的过程中进程会从<strong>用户态进入到内核态</strong>，最后会调用到 <code>sock_sendmsg</code> 方法。</p><p>然后进入传输层，带上<code>TCP</code>头。网络层带上<code>IP</code>头，数据链路层带上 <code>MAC</code>头等一系列操作后。进入网卡的<strong>发送队列 ring buffer</strong> ，顺着网卡就发出去了。</p><p>回到 <code>ping</code> ， 整个过程也基本跟 <code>TCP</code> 发数据类似，差异的地方主要在于，创建 <code>socket</code> 的时候用的是  <code>socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)</code>，<code>SOCK_RAW</code> 是原始套接字 ，<strong>工作在网络层</strong>， 所以构建<code>ICMP</code>（网络层协议）的数据，是再合适不过了。ping 在进入内核态后最后也是调用的  <code>sock_sendmsg</code> 方法，进入到网络层后加上<strong>ICMP和IP头</strong>后，数据链路层加上<strong>MAC头</strong>，也是顺着网卡发出。因此 本质上ping 跟 普通应用发消息 在程序流程上没太大差别。</p><p>这也解释了<strong>为什么当你发现怀疑网络有问题的时候，别人第一时间是问你能ping通吗？</strong>因为可以简单理解为ping就是自己组了个数据包，让系统按着其他软件发送数据的路径往外发一遍，能通的话说明其他软件发的数据也能通。</p><h3 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h3><p>前面提到，有网的情况下，ping 最后是<strong>通过网卡</strong>将数据发送出去的。</p><p>那么断网的情况下，网卡已经不工作了，ping 回环地址却一切正常，我们可以看下这种情况下的工作原理。</p><p><img src="/../images/image-20221225125226127.png" alt="image-20221225125226127">ping回环地址</p><p>从应用层到传输层再到网络层。这段路径跟ping外网的时候是几乎是一样的。到了网络层，系统会根据目的IP，在路由表中获取对应的<strong>路由信息</strong>，而这其中就包含选择<strong>哪个网卡</strong>把消息发出。</p><p>当发现<strong>目标IP是外网IP</strong>时，会从”真网卡”发出。</p><p>当发现<strong>目标IP是回环地址</strong>时，就会选择<strong>本地网卡</strong>。</p><p>本地网卡，其实就是个**”假网卡”<strong>，它不像”真网卡”那样有个<code>ring buffer</code>什么的，”假网卡”会把数据推到一个叫 <code>input_pkt_queue</code> 的 <strong>链表</strong> 中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个</strong>软中断**。</p><p>专门处理软中断的工具人**”ksoftirqd”** （这是个<strong>内核线程</strong>），它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。</p><p><img src="/../images/image-20221225125244671.png" alt="image-20221225125244671">工具人ksoftirqd</p><p>ping 回环地址和<strong>通过TCP等各种协议发送数据到回环地址</strong>都是走这条路径。整条路径从发到收，都没有经过”真网卡”。<strong>之所以127.0.0.1叫本地回环地址，可以理解为，消息发出到这个地址上的话，就不会出网络，在本机打个转就又回来了。</strong>所以断网，依然能 <code>ping</code> 通 <code>127.0.0.1</code>。</p><h3 id="ping回环地址和ping本机地址有什么区别"><a href="#ping回环地址和ping本机地址有什么区别" class="headerlink" title="ping回环地址和ping本机地址有什么区别"></a>ping回环地址和ping本机地址有什么区别</h3><p>我们在mac里执行 <code>ifconfig</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384</span><br><span class="line">    inet 127.0.0.1 netmask 0xff000000</span><br><span class="line">    ...</span><br><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">    inet 192.168.31.6 netmask 0xffffff00 broadcast 192.168.31.255</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>能看到 <strong>lo0</strong>，表示本地回环接口，对应的地址，就是我们前面提到的 <strong>127.0.0.1</strong> ，也就是<strong>回环地址</strong>。</p><p>和 <strong>eth0</strong>，表示本机第一块网卡，对应的IP地址是<strong>192.168.31.6</strong>，管它叫<strong>本机IP</strong>。</p><p>之前一直认为ping本机IP的话会通过”真网卡”出去，然后遇到第一个路由器，再发回来到本机。</p><p>为了验证这个说法，可以进行抓包，但结果跟上面的说法并不相同。</p><p><img src="/../images/image-20221225125303230.png" alt="image-20221225125303230">ping 127.0.0.1</p><p><img src="/../images/image-20221225125324149.png" alt="image-20221225125324149">ping 本机地址</p><p>可以看到 ping 本机IP 跟 ping 回环地址一样，相关的网络数据，都是走的  <strong>lo0</strong>，本地回环接口，也就是前面提到的**”假网卡”**。</p><p>只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 <strong>ping回环地址和ping本机地址没有区别</strong>。</p><h3 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h3><p>回到文章开头动图里的提问，算是面试八股文里的老常客了。</p><p>以前第一次用 <code>nginx</code> 的时候，发现用这几个 <code>IP</code>，都能正常访问到 <code>nginx</code> 的欢迎网页。一度认为这几个 <code>IP</code> 都是一样的。</p><p><img src="/../images/image-20221225125340582.png" alt="image-20221225125340582">访问127.0.0.1:80</p><p><img src="/../images/image-20221225125352222.png" alt="image-20221225125352222">访问localhost:80</p><p><img src="/../images/image-20221225125404667.png" alt="image-20221225125404667">访问0.0.0.0:80</p><p><img src="/../images/image-20221225125416747.png" alt="image-20221225125416747">访问本机的IP地址</p><p>但本质上还是有些区别的。</p><p>首先 <code>localhost</code> 就不叫 <code>IP</code>，它是一个域名，就跟 <code>&quot;baidu.com&quot;</code>,是一个形式的东西，只不过默认会把它解析为 <code>127.0.0.1</code> ，当然这可以在 <code>/etc/hosts</code> 文件下进行修改。</p><p>所以默认情况下，使用 <code>localhost</code> 跟使用  <code>127.0.0.1</code> 确实是没区别的。</p><p>其次就是 <code>0.0.0.0</code>，执行 ping 0.0.0.0  ，是会失败的，因为它在<code>IPV4</code>中表示的是无效的<strong>目标地址</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ping 0.0.0.0</span><br><span class="line">PING 0.0.0.0 (0.0.0.0): 56 data bytes</span><br><span class="line">ping: sendto: No route to host</span><br><span class="line">ping: sendto: No route to host</span><br></pre></td></tr></table></figure><p>但它还是很有用处的，回想下，我们启动服务器的时候，一般会 <code>listen</code> 一个 IP 和端口，等待客户端的连接。</p><p>如果此时 <code>listen</code> 的是本机的 <code>0.0.0.0</code> , 那么它表示本机上的<strong>所有IPV4地址</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Address to accept any incoming messages. */</span><br><span class="line">#define    INADDR_ANY      ((unsigned long int) 0x00000000) /* 0.0.0.0   */</span><br></pre></td></tr></table></figure><p>举个例子。刚刚提到的 <code>127.0.0.1</code> 和 <code>192.168.31.6</code> ，都是本机的IPV4地址，如果监听 <code>0.0.0.0</code> ，那么用上面两个地址，都能访问到这个服务器。</p><p>当然， 客户端 <code>connect</code> 时，不能使用 <code>0.0.0.0</code> 。必须指明要连接哪个服务器IP。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”<strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前</strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li><li>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal内存泄漏</title>
      <link href="/2022/12/25/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2022/12/25/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocaln内存泄漏"><a href="#ThreadLocaln内存泄漏" class="headerlink" title="ThreadLocaln内存泄漏"></a>ThreadLocaln内存泄漏</h1><h1 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h1><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><p>下图为ThreadLocal的内部结构图</p><p><img src="/../images/image-20221225124856643.png" alt="image-20221225124856643"> </p><p><strong>从上面的结构图，我们已经窥见ThreadLocal的核心机制：</strong></p><ul><li>每个Thread线程内部都有一个Map。</li><li>Map里面存储线程本地对象（key）和线程的变量副本（value）</li><li>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li></ul><p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p><h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p><img src="/../images/image-20221225124921832.png" alt="image-20221225124921832"><br>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><p>和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是<code>采用线性探测的方式</code>。（<strong>ThreadLocalMap如何解决冲突？</strong>）</p><p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意了！！</code><br><strong>Entry继承自WeakReference（<code>弱引用，生命周期只能存活到下次GC前</code>），但只有Key是弱引用类型的，Value并非弱引用。</strong>（<code>问题马上就来了</code>）</p><p>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，<strong>发生GC时弱引用Key会被回收，而Value不会回收</strong>。</p><p>当线程没有结束，但是ThreadLocal已经被回收，则可能导致线程中存在ThreadLocalMap&lt;null, Object&gt;的键值对，<strong>造成内存泄露。</strong>（<code>ThreadLocal被回收，ThreadLocal关联的线程共享变量还存在</code>）。</p><h1 id="如何避免泄漏"><a href="#如何避免泄漏" class="headerlink" title="如何避免泄漏"></a>如何避免泄漏</h1><p>为了防止此类情况的出现，我们有两种手段。</p><p>1、使用完线程共享变量后，显示调用ThreadLocalMap.remove方法清除线程共享变量；</p><p>既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再<strong>调用remove方法，将Entry节点和Map的引用关系移除</strong>，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。</p><p>2、JDK建议ThreadLocal定义为private static，这样ThreadLocal的弱引用问题则不存在了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2022/12/24/ThreadLocal/"/>
      <url>/2022/12/24/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<p><img src="/../images/image-20221224231606153.png" alt="image-20221224231606153"></p><ul><li>ThreadLocal的作用以及应用场景</li><li>使用场景</li><li>原理分析</li><li>ThreadLocalMap的底层结构</li><li>内存泄露产生的原因</li><li>解决Hash冲突</li><li>使用ThreadLocal时对象存在哪里？</li></ul><hr><h2 id="ThreadLocal的作用以及应用场景"><a href="#ThreadLocal的作用以及应用场景" class="headerlink" title="ThreadLocal的作用以及应用场景"></a><strong>ThreadLocal的作用以及应用场景</strong></h2><p><code>ThreadLocal</code>算是一种并发容器吧，因为他的内部是有<code>ThreadLocalMap</code>组成，<code>ThreadLocal</code>是为了解决多线程情况下变量不能被共享的问题，也就是多线程共享变量的问题。</p><p><code>ThreadLocal</code>和<code>Lock</code>以及<code>Synchronized</code>的区别是：<code>ThreadLocal</code>是给每个线程分配一个变量（对象），各个线程都存有变量的副本，这样每个线程都是使用自己（变量）对象实例，使线程与线程之间进行隔离；而<code>Lock</code>和<code>Synchronized</code>的方式是使线程有顺序的执行。</p><p>举一个简单的例子：目前有100个学生等待签字，但是老师只有一个笔，那老师只能按顺序的分给每个学生，等待A学生签字完成然后将笔交给B学生，这就类似<code>Lock</code>，<code>Synchronized</code>的方式。而<code>ThreadLocal</code>是，老师直接拿出一百个笔给每个学生；再效率提高的同事也要付出一个内存消耗；也就是以空间换时间的概念</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><p>Spring的事务隔离就是使用<code>ThreadLocal</code>和AOP来解决的；主要是<code>TransactionSynchronizationManager</code>这个类；</p><p>解决<code>SimpleDateFormat</code>线程不安全问题；</p><p>当我们使用<code>SimpleDateFormat</code>的<code>parse()</code>方法的时候，<code>parse()</code>方法会先调用<code>Calendar.clear()</code>方法，然后调用<code>Calendar.add()</code>方法，如果一个线程先调用了<code>add()</code>方法，然后另一个线程调用了<code>clear()</code>方法；这时候<code>parse()</code>方法就会出现解析错误；如果不信我们可以来个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    dateFormat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 字符串转成日期类型</span><br><span class="line">     */</span><br><span class="line">    public static void dateFormat() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            simpleDateFormat.parse(&quot;2021-5-27&quot;);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只启动了50个线程问题就会出现，其实看巧不巧，有时候只有10个线程的情况就会出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-40&quot; java.lang.NumberFormatException: For input string: &quot;&quot;</span><br><span class="line"> at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line"> at java.lang.Long.parseLong(Long.java:601)</span><br><span class="line"> at java.lang.Long.parseLong(Long.java:631)</span><br><span class="line"> at java.text.DigitList.getLong(DigitList.java:195)</span><br><span class="line"> at java.text.DecimalFormat.parse(DecimalFormat.java:2084)</span><br><span class="line"> at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line"> at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line"> at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line"> at cn.haoxy.use.lock.sdf.SimpleDateFormatTest.dateFormat(SimpleDateFormatTest.java:36)</span><br><span class="line"> at cn.haoxy.use.lock.sdf.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:23)</span><br><span class="line"> at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;Thread-43&quot; java.lang.NumberFormatException: multiple points</span><br><span class="line"> at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line"> at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line"> at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line"> at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line"> at java.text.DecimalFormat.parse(DecimalFormat.java:2089)</span><br><span class="line"> at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line"> at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line"> at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line"> at  .............</span><br></pre></td></tr></table></figure><p>其实解决这个问题很简单，让每个线程new一个自己的<code>SimpleDateFormat</code>，但是如果100个线程都要new100个<code>SimpleDateFormat</code>吗？</p><p>当然我们不能这么做，我们可以借助线程池加上<code>ThreadLocal</code>来解决这个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;SimpleDateFormat&gt; local = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">       //初始化线程本地变量</span><br><span class="line">        protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">            es.execute(() -&gt; &#123;</span><br><span class="line">               //调用字符串转成日期方法</span><br><span class="line">                dateFormat();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 字符串转成日期类型</span><br><span class="line">     */</span><br><span class="line">    public static void dateFormat() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           //ThreadLocal中的get()方法</span><br><span class="line">            local.get().parse(&quot;2021-5-27&quot;);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就优雅的解决了线程安全问题；</p><p>解决过度传参问题；例如一个方法中要调用好多个方法，每个方法都需要传递参数；例如下面示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void work(User user) &#123;</span><br><span class="line">    getInfo(user);</span><br><span class="line">    checkInfo(user);</span><br><span class="line">    setSomeThing(user);</span><br><span class="line">    log(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了<code>ThreadLocal</code>之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalStu &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;User&gt; userThreadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    void work(User user) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            userThreadLocal.set(user);</span><br><span class="line">            getInfo();</span><br><span class="line">            checkInfo();</span><br><span class="line">            someThing();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            userThreadLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setInfo() &#123;</span><br><span class="line">        User u = userThreadLocal.get();</span><br><span class="line">        //.....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void checkInfo() &#123;</span><br><span class="line">        User u = userThreadLocal.get();</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void someThing() &#123;</span><br><span class="line">        User u = userThreadLocal.get();</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程内需要保存全局变量（比如在登录成功后将用户信息存到<code>ThreadLocal</code>里，然后当前线程操作的业务逻辑直接get取就完事了，有效的避免的参数来回传递的麻烦之处），一定层级上减少代码耦合度。</p><ul><li>比如存储 交易id等信息。每个线程私有。</li><li>比如aop里记录日志需要before记录请求id，end拿出请求id，这也可以。</li><li>比如jdbc连接池（很典型的一个<code>ThreadLocal</code>用法）</li><li>….等等….</li></ul><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a><strong>原理分析</strong></h2><p>上面我们基本上知道了<code>ThreadLocal</code>的使用方式以及应用场景，当然应用场景不止这些这只是工作中常用到的场景；下面我们对它的原理进行分析;</p><p>我们先看一下它的<code>set()</code>方法;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是特别简单，首先获取当前线程，用当前线程作为key,去获取<code>ThreadLocalMap</code>,然后判断map是否为空，不为空就将当前线程作为key,传入的value作为map的value值；如果为空就创建一个<code>ThreadLocalMap</code>,然后将key和value方进去；从这里可以看出value值是存放到<code>ThreadLocalMap</code>中；</p><p>然后我们看看<code>ThreadLocalMap</code>是怎么来的？先看下<code>getMap()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在Thread类中维护了threadLocals变量，注意是Thread类</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null; </span><br><span class="line"></span><br><span class="line">//在ThreadLocal类中的getMap()方法</span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这就能解释每个线程中都有一个<code>ThreadLocalMap</code>，因为<code>ThreadLocalMap</code>的引用在Thread中维护；这就确保了线程间的隔离；</p><p>我们继续回到<code>set()</code>方法，看到当map等于空的时候<code>createMap(t, value);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">      t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里就是new了一个<code>ThreadLocalMap</code>然后赋值给<code>threadLocals</code>成员变量；<code>ThreadLocalMap</code>构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">  //初始化一个Entry   </span><br><span class="line">  table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">   //计算key应该存放的位置</span><br><span class="line">   int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">   //将Entry放到指定位置</span><br><span class="line">   table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">   size = 1;</span><br><span class="line">   //设置数组的大小 16*2/3=10,类似HashMap中的0.75*16=12</span><br><span class="line">   setThreshold(INITIAL_CAPACITY);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里写有个大概的印象，后面对<code>ThreadLocalMap</code>内部结构还会进行详细的讲解；</p><p>下面我们再去看一下<code>get()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">   //用当前线程作为key去获取ThreadLocalMap</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">       //map不为空，然后获取map中的Entry</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">           //如果Entry不为空就获取对应的value值</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   //如果map为空或者entry为空的话通过该方法初始化，并返回该方法的value</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get()</code>方法和<code>set()</code>都比较容易理解，如果map等于空的时候或者entry等于空的时候我们看看<code>setInitialValue()</code>方法做了什么事：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">  //初始化变量值 由子类去实现并初始化变量</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">   //这里再次getMap();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">  //和set()方法中的</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们再去看一下<code>ThreadLocal</code>中的<code>initialValue()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected T initialValue() &#123;</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>设置初始值，由子类去实现；就例如我们上面的例子，重写<code>ThreadLocal</code>类中的<code>initialValue()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal&lt;SimpleDateFormat&gt; local = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">   //初始化线程本地变量</span><br><span class="line">    protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>createMap()</code>方法和上面<code>set()</code>方法中<code>createMap()</code>方法同一个，就不过多的叙述了；剩下还有一个<code>removve()</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">      ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">      if (m != null)</span><br><span class="line">        //2. 从map中删除以当前threadLocal实例为key的键值对</span><br><span class="line">          m.remove(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>源码的讲解就到这里，也都比较好理解，下面我们看看<code>ThreadLocalMap</code>的底层结构</p><h2 id="ThreadLocalMap的底层结构"><a href="#ThreadLocalMap的底层结构" class="headerlink" title="ThreadLocalMap的底层结构"></a><strong>ThreadLocalMap的底层结构</strong></h2><p>上面我们已经了解了<code>ThreadLocal</code>的使用场景以及它比较重要的几个方法；下面我们再去它的内部结构；经过上的源码分析我们可以看到数据其实都是存放到了<code>ThreadLocal</code>中的内部类<code>ThreadLocalMap</code>中；而<code>ThreadLocalMap</code>中又维护了一个Entry对象，也就说数据最终是存放到Entry对象中的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            /** The value associated with this ThreadLocal. */</span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">          ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">            table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">            size = 1;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">  // ....................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry的构造方法是以当前线程为key,变量值Object为value进行存储的；在上面的源码中<code>ThreadLocalMap</code>的构造方法中也涉及到了Entry；看到Entry是一个数组；初始化长度为<code>INITIAL_CAPACITY = 16；</code>因为 Entry 继承了 <code>WeakReference</code>，在 Entry 的构造方法中，调用了<code> super(k)</code>方法就会将 <code>threadLocal</code> 实例包装成一个 <code>WeakReferenece</code>。这也是<code>ThreadLocal</code>会产生内存泄露的原因；</p><h2 id="内存泄露产生的原因"><a href="#内存泄露产生的原因" class="headerlink" title="内存泄露产生的原因"></a><strong>内存泄露产生的原因</strong></h2><p><img src="/../images/image-20221224232314960.png" alt="image-20221224232314960"></p><p>如图所示存在一条引用链：<code>Thread Ref-&gt;Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;Key:Value</code>，经过上面的讲解我们知道<code>ThreadLocal</code>作为Key,但是被设置成了弱引用，弱引用在JVM垃圾回收时是优先回收的，就是说无论内存是否足够弱引用对象都会被回收；弱引用的生命周期比较短；当发生一次GC的时候就会变成如下：</p><p><img src="/../images/image-20221224232336814.png" alt="image-20221224232336814"></p><p><code>TreadLocalMap</code>中出现了Key为null的Entry，就没有办法访问这些key为null的Entry的value,如果线程迟迟不结束（也就是说这条引用链无意义的一直存在）就会造成value永远无法回收造成内存泄露；如果当前线程运行结束Thread，<code>ThreadLocalMap</code>,Entry之间没有了引用链，在垃圾回收的时候就会被回收；但是在开发中我们都是使用线程池的方式，线程池的复用不会主动结束；所以还是会存在内存泄露问题；</p><p>解决方法也很简单，就是在使用完之后主动调用<code>remove()</code>方法释放掉；</p><h2 id="解决Hash冲突"><a href="#解决Hash冲突" class="headerlink" title="解决Hash冲突"></a><strong>解决Hash冲突</strong></h2><p>记得在大学学习数据结构的时候学习了很多种解决hash冲突的方法;例如：</p><p><strong>线性探测法（开放地址法的一种）：</strong> 计算出的散列地址如果已被占用，则按顺序找下一个空位。如果找到末尾还没有找到空位置就从头重新开始找；</p><p><img src="/../images/image-20221224232357557.png" alt="image-20221224232357557"></p><p>图片</p><p><strong>二次探测法（开放地址法的一种）</strong></p><p><img src="/../images/image-20221224232414070.png" alt="image-20221224232414070"></p><p>图片</p><p>链地址法：链地址是对每一个同义词都建一个单链表来解决冲突，HashMap采用的是这种方法；</p><p><img src="/../images/image-20221224232429196.png" alt="image-20221224232429196"></p><p><strong>多重Hash法：</strong> 在key冲突的情况下多重hash,直到不冲突为止，这种方式不易产生堆积但是计算量太大；</p><p><strong>公共溢出区法：</strong> 这种方式需要两个表，一个存基础数据，另一个存放冲突数据称为溢出表；</p><p>上面的图片都是在网上找到的一些资料，和大学时学习时的差不多我就直接拿来用了；也当自己复习了一遍；</p><p>介绍了那么多解决Hash冲突的方法，那<code>ThreadLocalMap</code>使用的哪一种方法呢？我们可以看一下源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           int len = tab.length;</span><br><span class="line">      //根据HashCode &amp; 数组长度 计算出数组该存放的位置</span><br><span class="line">           int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    //遍历Entry数组中的元素</span><br><span class="line">           for (Entry e = tab[i];</span><br><span class="line">                e != null;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">     //如果这个Entry对象的key正好是即将设置的key，那么就刷新Entry中的value；</span><br><span class="line">               if (k == key) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">    // entry!=null,key==null时，说明threadLcoal这key已经被GC了，这里就是上面说到</span><br><span class="line">    //会有内存泄露的地方，当然作者也知道这种情况的存在，所以这里做了一个判断进行解决脏的</span><br><span class="line">    //entry（数组中不想存有过时的entry），但是也不能解决泄露问题，因为旧value还存在没有消失</span><br><span class="line">               if (k == null) &#123;</span><br><span class="line">                 //用当前插入的值代替掉这个key为null的“脏”entry</span><br><span class="line">                   replaceStaleEntry(key, value, i);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   //新建entry并插入table中i处</span><br><span class="line">           tab[i] = new Entry(key, value);</span><br><span class="line">           int sz = ++size;</span><br><span class="line">           if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">               rehash();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看出使用的是线性探测的方式来解决hash冲突！</p><p>源码中通过<code>nextIndex(i, len)</code>方法解决 hash 冲突的问题，该方法为<code>((i + 1 &lt; len) ? i + 1 : 0);</code>，也就是不断往后线性探测，直到找到一个空的位置，当到哈希表末尾的时候还没有找到空位置再从 0 开始找，成环形！</p><h2 id="使用ThreadLocal时对象存在哪里？"><a href="#使用ThreadLocal时对象存在哪里？" class="headerlink" title="使用ThreadLocal时对象存在哪里？"></a><strong>使用ThreadLocal时对象存在哪里？</strong></h2><p>在java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有变量，而堆内存中的变量对所有线程可见，可以被所有线程访问！</p><p>那么<code>ThreadLocal</code>的实例以及它的值是不是存放在栈上呢？其实不是的，因为<code>ThreadLocal</code>的实例实际上也是被其创建的类持有，（更顶端应该是被线程持有），而<code>ThreadLocal</code>的值其实也是被线程实例持有，它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {  left: -125px;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px var(--theme-color) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px var(--theme-color) !important;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{  display: block;  position: fixed;  margin: 0;  padding: 0;  border: 0;  outline: 0;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */  z-index: -1;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Gallery</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用        if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";            if (document.getElementById("site-title"))                document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";            if (document.getElementById("post-info"))                document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";                document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {            }            idx++;            if (idx == 8) {                idx = 0;        }    } else {            // 白天模式恢复默认            if (document.getElementById("site-name"))                document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";            if (document.getElementById("site-subtitle"))                document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";            try {                document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";            } catch {        }    }    }    // 开启计时器    window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
